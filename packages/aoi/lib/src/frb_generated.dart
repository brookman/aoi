// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.31';

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'embedded_aoi',
    ioDirectory: 'native/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<List<AoiAdapter>> aoiAdapterGetAdapters({dynamic hint});

  Future<Stream<AoiPeripheral>> aoiAdapterStartScan(
      {required AoiAdapter that, FilterCriteria? filter, dynamic hint});

  Future<void> aoiAdapterStopScan({required AoiAdapter that, dynamic hint});

  Future<void> aoiConnectedPeripheralDisconnect(
      {required AoiConnectedPeripheral that, dynamic hint});

  Future<Uint8List> aoiConnectedPeripheralRead(
      {required AoiConnectedPeripheral that,
      required AoiCharacteristic characteristic,
      dynamic hint});

  Future<void> aoiConnectedPeripheralWrite(
      {required AoiConnectedPeripheral that,
      required AoiCharacteristic characteristic,
      required List<int> data,
      dynamic hint});

  Future<void> aoiConnectedPeripheralWriteWithoutResponse(
      {required AoiConnectedPeripheral that,
      required AoiCharacteristic characteristic,
      required List<int> data,
      dynamic hint});

  Future<AoiConnectedPeripheral> aoiPeripheralConnect(
      {required AoiPeripheral that, dynamic hint});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<List<AoiAdapter>> aoiAdapterGetAdapters({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire_aoi_adapter_get_adapters(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_aoi_adapter,
        decodeErrorData: null,
      ),
      constMeta: kAoiAdapterGetAdaptersConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAoiAdapterGetAdaptersConstMeta => const TaskConstMeta(
        debugName: "aoi_adapter_get_adapters",
        argNames: [],
      );

  @override
  Future<Stream<AoiPeripheral>> aoiAdapterStartScan(
      {required AoiAdapter that, FilterCriteria? filter, dynamic hint}) async {
    final sink = RustStreamSink<AoiPeripheral>();
    await handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_aoi_adapter(that);
        var arg1 = cst_encode_opt_box_autoadd_filter_criteria(filter);
        var arg2 = cst_encode_StreamSink_aoi_peripheral_Dco(sink);
        return wire.wire_aoi_adapter_start_scan(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kAoiAdapterStartScanConstMeta,
      argValues: [that, filter, sink],
      apiImpl: this,
      hint: hint,
    ));
    return sink.stream;
  }

  TaskConstMeta get kAoiAdapterStartScanConstMeta => const TaskConstMeta(
        debugName: "aoi_adapter_start_scan",
        argNames: ["that", "filter", "sink"],
      );

  @override
  Future<void> aoiAdapterStopScan({required AoiAdapter that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_aoi_adapter(that);
        return wire.wire_aoi_adapter_stop_scan(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kAoiAdapterStopScanConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAoiAdapterStopScanConstMeta => const TaskConstMeta(
        debugName: "aoi_adapter_stop_scan",
        argNames: ["that"],
      );

  @override
  Future<void> aoiConnectedPeripheralDisconnect(
      {required AoiConnectedPeripheral that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_aoi_connected_peripheral(that);
        return wire.wire_aoi_connected_peripheral_disconnect(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kAoiConnectedPeripheralDisconnectConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAoiConnectedPeripheralDisconnectConstMeta =>
      const TaskConstMeta(
        debugName: "aoi_connected_peripheral_disconnect",
        argNames: ["that"],
      );

  @override
  Future<Uint8List> aoiConnectedPeripheralRead(
      {required AoiConnectedPeripheral that,
      required AoiCharacteristic characteristic,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_aoi_connected_peripheral(that);
        var arg1 = cst_encode_box_autoadd_aoi_characteristic(characteristic);
        return wire.wire_aoi_connected_peripheral_read(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kAoiConnectedPeripheralReadConstMeta,
      argValues: [that, characteristic],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAoiConnectedPeripheralReadConstMeta => const TaskConstMeta(
        debugName: "aoi_connected_peripheral_read",
        argNames: ["that", "characteristic"],
      );

  @override
  Future<void> aoiConnectedPeripheralWrite(
      {required AoiConnectedPeripheral that,
      required AoiCharacteristic characteristic,
      required List<int> data,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_aoi_connected_peripheral(that);
        var arg1 = cst_encode_box_autoadd_aoi_characteristic(characteristic);
        var arg2 = cst_encode_list_prim_u_8_loose(data);
        return wire.wire_aoi_connected_peripheral_write(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kAoiConnectedPeripheralWriteConstMeta,
      argValues: [that, characteristic, data],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAoiConnectedPeripheralWriteConstMeta =>
      const TaskConstMeta(
        debugName: "aoi_connected_peripheral_write",
        argNames: ["that", "characteristic", "data"],
      );

  @override
  Future<void> aoiConnectedPeripheralWriteWithoutResponse(
      {required AoiConnectedPeripheral that,
      required AoiCharacteristic characteristic,
      required List<int> data,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_aoi_connected_peripheral(that);
        var arg1 = cst_encode_box_autoadd_aoi_characteristic(characteristic);
        var arg2 = cst_encode_list_prim_u_8_loose(data);
        return wire.wire_aoi_connected_peripheral_write_without_response(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kAoiConnectedPeripheralWriteWithoutResponseConstMeta,
      argValues: [that, characteristic, data],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAoiConnectedPeripheralWriteWithoutResponseConstMeta =>
      const TaskConstMeta(
        debugName: "aoi_connected_peripheral_write_without_response",
        argNames: ["that", "characteristic", "data"],
      );

  @override
  Future<AoiConnectedPeripheral> aoiPeripheralConnect(
      {required AoiPeripheral that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_aoi_peripheral(that);
        return wire.wire_aoi_peripheral_connect(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_aoi_connected_peripheral,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kAoiPeripheralConnectConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAoiPeripheralConnectConstMeta => const TaskConstMeta(
        debugName: "aoi_peripheral_connect",
        argNames: ["that"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  RustStreamSink<AoiPeripheral> dco_decode_StreamSink_aoi_peripheral_Dco(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AoiAdapter dco_decode_aoi_adapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return AoiAdapter(
      index: dco_decode_usize(arr[0]),
    );
  }

  @protected
  AoiCharacteristic dco_decode_aoi_characteristic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AoiCharacteristic(
      uuid: dco_decode_String(arr[0]),
      serviceUuid: dco_decode_String(arr[1]),
      propertiesBits: dco_decode_u_8(arr[2]),
      descriptors: dco_decode_list_aoi_descriptor(arr[3]),
    );
  }

  @protected
  AoiConnectedPeripheral dco_decode_aoi_connected_peripheral(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AoiConnectedPeripheral(
      peripheral: dco_decode_box_aoi_peripheral(arr[0]),
      characteristics: dco_decode_list_aoi_characteristic(arr[1]),
    );
  }

  @protected
  AoiDescriptor dco_decode_aoi_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return AoiDescriptor(
      uuid: dco_decode_String(arr[0]),
      serviceUuid: dco_decode_String(arr[1]),
      characteristicUuid: dco_decode_String(arr[2]),
    );
  }

  @protected
  AoiManufacturerData dco_decode_aoi_manufacturer_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AoiManufacturerData(
      manufacturerId: dco_decode_u_16(arr[0]),
      data: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  AoiPeripheral dco_decode_aoi_peripheral(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return AoiPeripheral(
      adapter: dco_decode_box_aoi_adapter(arr[0]),
      name: dco_decode_opt_String(arr[1]),
      address: dco_decode_box_aoi_peripheral_address(arr[2]),
      services: dco_decode_list_String(arr[3]),
      manufacturerData: dco_decode_list_aoi_manufacturer_data(arr[4]),
    );
  }

  @protected
  AoiPeripheralAddress dco_decode_aoi_peripheral_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AoiPeripheralAddress_MacAddress(
          dco_decode_u_8_array_6(raw[1]),
        );
      case 1:
        return AoiPeripheralAddress_Uuid(
          dco_decode_String(raw[1]),
        );
      case 2:
        return AoiPeripheralAddress_DeviceId(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AoiAdapter dco_decode_box_aoi_adapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aoi_adapter(raw);
  }

  @protected
  AoiPeripheral dco_decode_box_aoi_peripheral(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aoi_peripheral(raw);
  }

  @protected
  AoiPeripheralAddress dco_decode_box_aoi_peripheral_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aoi_peripheral_address(raw);
  }

  @protected
  AoiAdapter dco_decode_box_autoadd_aoi_adapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aoi_adapter(raw);
  }

  @protected
  AoiCharacteristic dco_decode_box_autoadd_aoi_characteristic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aoi_characteristic(raw);
  }

  @protected
  AoiConnectedPeripheral dco_decode_box_autoadd_aoi_connected_peripheral(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aoi_connected_peripheral(raw);
  }

  @protected
  AoiPeripheral dco_decode_box_autoadd_aoi_peripheral(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_aoi_peripheral(raw);
  }

  @protected
  FilterCriteria dco_decode_box_autoadd_filter_criteria(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_filter_criteria(raw);
  }

  @protected
  FilterCriteria dco_decode_filter_criteria(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FilterCriteria_Any(
          dco_decode_list_filter_criterion(raw[1]),
        );
      case 1:
        return FilterCriteria_All(
          dco_decode_list_filter_criterion(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  FilterCriterion dco_decode_filter_criterion(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FilterCriterion_HasServiceUuid(
          dco_decode_String(raw[1]),
        );
      case 1:
        return FilterCriterion_NameMatchesExactly(
          dco_decode_String(raw[1]),
        );
      case 2:
        return FilterCriterion_NameContains(
          dco_decode_String(raw[1]),
        );
      case 3:
        return FilterCriterion_ManufacturerId(
          dco_decode_u_16(raw[1]),
        );
      case 4:
        return FilterCriterion_ManufacturerData(
          dco_decode_u_16(raw[1]),
          dco_decode_list_prim_u_8_strict(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<AoiAdapter> dco_decode_list_aoi_adapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_aoi_adapter).toList();
  }

  @protected
  List<AoiCharacteristic> dco_decode_list_aoi_characteristic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_aoi_characteristic).toList();
  }

  @protected
  List<AoiDescriptor> dco_decode_list_aoi_descriptor(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_aoi_descriptor).toList();
  }

  @protected
  List<AoiManufacturerData> dco_decode_list_aoi_manufacturer_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_aoi_manufacturer_data)
        .toList();
  }

  @protected
  List<FilterCriterion> dco_decode_list_filter_criterion(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_filter_criterion).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  FilterCriteria? dco_decode_opt_box_autoadd_filter_criteria(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_filter_criteria(raw);
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U8Array6 dco_decode_u_8_array_6(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array6(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  RustStreamSink<AoiPeripheral> sse_decode_StreamSink_aoi_peripheral_Dco(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AoiAdapter sse_decode_aoi_adapter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_index = sse_decode_usize(deserializer);
    return AoiAdapter(index: var_index);
  }

  @protected
  AoiCharacteristic sse_decode_aoi_characteristic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uuid = sse_decode_String(deserializer);
    var var_serviceUuid = sse_decode_String(deserializer);
    var var_propertiesBits = sse_decode_u_8(deserializer);
    var var_descriptors = sse_decode_list_aoi_descriptor(deserializer);
    return AoiCharacteristic(
        uuid: var_uuid,
        serviceUuid: var_serviceUuid,
        propertiesBits: var_propertiesBits,
        descriptors: var_descriptors);
  }

  @protected
  AoiConnectedPeripheral sse_decode_aoi_connected_peripheral(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_peripheral = sse_decode_box_aoi_peripheral(deserializer);
    var var_characteristics = sse_decode_list_aoi_characteristic(deserializer);
    return AoiConnectedPeripheral(
        peripheral: var_peripheral, characteristics: var_characteristics);
  }

  @protected
  AoiDescriptor sse_decode_aoi_descriptor(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uuid = sse_decode_String(deserializer);
    var var_serviceUuid = sse_decode_String(deserializer);
    var var_characteristicUuid = sse_decode_String(deserializer);
    return AoiDescriptor(
        uuid: var_uuid,
        serviceUuid: var_serviceUuid,
        characteristicUuid: var_characteristicUuid);
  }

  @protected
  AoiManufacturerData sse_decode_aoi_manufacturer_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_manufacturerId = sse_decode_u_16(deserializer);
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return AoiManufacturerData(
        manufacturerId: var_manufacturerId, data: var_data);
  }

  @protected
  AoiPeripheral sse_decode_aoi_peripheral(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_adapter = sse_decode_box_aoi_adapter(deserializer);
    var var_name = sse_decode_opt_String(deserializer);
    var var_address = sse_decode_box_aoi_peripheral_address(deserializer);
    var var_services = sse_decode_list_String(deserializer);
    var var_manufacturerData =
        sse_decode_list_aoi_manufacturer_data(deserializer);
    return AoiPeripheral(
        adapter: var_adapter,
        name: var_name,
        address: var_address,
        services: var_services,
        manufacturerData: var_manufacturerData);
  }

  @protected
  AoiPeripheralAddress sse_decode_aoi_peripheral_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_8_array_6(deserializer);
        return AoiPeripheralAddress_MacAddress(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return AoiPeripheralAddress_Uuid(var_field0);
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return AoiPeripheralAddress_DeviceId(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AoiAdapter sse_decode_box_aoi_adapter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aoi_adapter(deserializer));
  }

  @protected
  AoiPeripheral sse_decode_box_aoi_peripheral(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aoi_peripheral(deserializer));
  }

  @protected
  AoiPeripheralAddress sse_decode_box_aoi_peripheral_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aoi_peripheral_address(deserializer));
  }

  @protected
  AoiAdapter sse_decode_box_autoadd_aoi_adapter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aoi_adapter(deserializer));
  }

  @protected
  AoiCharacteristic sse_decode_box_autoadd_aoi_characteristic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aoi_characteristic(deserializer));
  }

  @protected
  AoiConnectedPeripheral sse_decode_box_autoadd_aoi_connected_peripheral(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aoi_connected_peripheral(deserializer));
  }

  @protected
  AoiPeripheral sse_decode_box_autoadd_aoi_peripheral(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_aoi_peripheral(deserializer));
  }

  @protected
  FilterCriteria sse_decode_box_autoadd_filter_criteria(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_filter_criteria(deserializer));
  }

  @protected
  FilterCriteria sse_decode_filter_criteria(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_list_filter_criterion(deserializer);
        return FilterCriteria_Any(var_field0);
      case 1:
        var var_field0 = sse_decode_list_filter_criterion(deserializer);
        return FilterCriteria_All(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  FilterCriterion sse_decode_filter_criterion(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return FilterCriterion_HasServiceUuid(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return FilterCriterion_NameMatchesExactly(var_field0);
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return FilterCriterion_NameContains(var_field0);
      case 3:
        var var_field0 = sse_decode_u_16(deserializer);
        return FilterCriterion_ManufacturerId(var_field0);
      case 4:
        var var_field0 = sse_decode_u_16(deserializer);
        var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
        return FilterCriterion_ManufacturerData(var_field0, var_field1);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<AoiAdapter> sse_decode_list_aoi_adapter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AoiAdapter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_aoi_adapter(deserializer));
    }
    return ans_;
  }

  @protected
  List<AoiCharacteristic> sse_decode_list_aoi_characteristic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AoiCharacteristic>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_aoi_characteristic(deserializer));
    }
    return ans_;
  }

  @protected
  List<AoiDescriptor> sse_decode_list_aoi_descriptor(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AoiDescriptor>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_aoi_descriptor(deserializer));
    }
    return ans_;
  }

  @protected
  List<AoiManufacturerData> sse_decode_list_aoi_manufacturer_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AoiManufacturerData>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_aoi_manufacturer_data(deserializer));
    }
    return ans_;
  }

  @protected
  List<FilterCriterion> sse_decode_list_filter_criterion(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FilterCriterion>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_filter_criterion(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  FilterCriteria? sse_decode_opt_box_autoadd_filter_criteria(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_filter_criteria(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  U8Array6 sse_decode_u_8_array_6(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array6(inner);
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_usize(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  void sse_encode_StreamSink_aoi_peripheral_Dco(
      RustStreamSink<AoiPeripheral> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: DcoCodec(
                decodeSuccessData: dco_decode_aoi_peripheral,
                decodeErrorData: null)),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_aoi_adapter(AoiAdapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.index, serializer);
  }

  @protected
  void sse_encode_aoi_characteristic(
      AoiCharacteristic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.uuid, serializer);
    sse_encode_String(self.serviceUuid, serializer);
    sse_encode_u_8(self.propertiesBits, serializer);
    sse_encode_list_aoi_descriptor(self.descriptors, serializer);
  }

  @protected
  void sse_encode_aoi_connected_peripheral(
      AoiConnectedPeripheral self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_box_aoi_peripheral(self.peripheral, serializer);
    sse_encode_list_aoi_characteristic(self.characteristics, serializer);
  }

  @protected
  void sse_encode_aoi_descriptor(AoiDescriptor self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.uuid, serializer);
    sse_encode_String(self.serviceUuid, serializer);
    sse_encode_String(self.characteristicUuid, serializer);
  }

  @protected
  void sse_encode_aoi_manufacturer_data(
      AoiManufacturerData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self.manufacturerId, serializer);
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_aoi_peripheral(AoiPeripheral self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_box_aoi_adapter(self.adapter, serializer);
    sse_encode_opt_String(self.name, serializer);
    sse_encode_box_aoi_peripheral_address(self.address, serializer);
    sse_encode_list_String(self.services, serializer);
    sse_encode_list_aoi_manufacturer_data(self.manufacturerData, serializer);
  }

  @protected
  void sse_encode_aoi_peripheral_address(
      AoiPeripheralAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AoiPeripheralAddress_MacAddress(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8_array_6(field0, serializer);
      case AoiPeripheralAddress_Uuid(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case AoiPeripheralAddress_DeviceId(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_box_aoi_adapter(AoiAdapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aoi_adapter(self, serializer);
  }

  @protected
  void sse_encode_box_aoi_peripheral(
      AoiPeripheral self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aoi_peripheral(self, serializer);
  }

  @protected
  void sse_encode_box_aoi_peripheral_address(
      AoiPeripheralAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aoi_peripheral_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aoi_adapter(
      AoiAdapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aoi_adapter(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aoi_characteristic(
      AoiCharacteristic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aoi_characteristic(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aoi_connected_peripheral(
      AoiConnectedPeripheral self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aoi_connected_peripheral(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_aoi_peripheral(
      AoiPeripheral self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_aoi_peripheral(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_filter_criteria(
      FilterCriteria self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_filter_criteria(self, serializer);
  }

  @protected
  void sse_encode_filter_criteria(
      FilterCriteria self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FilterCriteria_Any(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_list_filter_criterion(field0, serializer);
      case FilterCriteria_All(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_list_filter_criterion(field0, serializer);
    }
  }

  @protected
  void sse_encode_filter_criterion(
      FilterCriterion self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FilterCriterion_HasServiceUuid(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case FilterCriterion_NameMatchesExactly(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case FilterCriterion_NameContains(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
      case FilterCriterion_ManufacturerId(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_u_16(field0, serializer);
      case FilterCriterion_ManufacturerData(
          field0: final field0,
          field1: final field1
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_u_16(field0, serializer);
        sse_encode_list_prim_u_8_strict(field1, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_aoi_adapter(
      List<AoiAdapter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_aoi_adapter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_aoi_characteristic(
      List<AoiCharacteristic> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_aoi_characteristic(item, serializer);
    }
  }

  @protected
  void sse_encode_list_aoi_descriptor(
      List<AoiDescriptor> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_aoi_descriptor(item, serializer);
    }
  }

  @protected
  void sse_encode_list_aoi_manufacturer_data(
      List<AoiManufacturerData> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_aoi_manufacturer_data(item, serializer);
    }
  }

  @protected
  void sse_encode_list_filter_criterion(
      List<FilterCriterion> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_filter_criterion(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_filter_criteria(
      FilterCriteria? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_filter_criteria(self, serializer);
    }
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_u_8_array_6(U8Array6 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }
}
